/*
 *  Network Calculations Library
 *  Copyright (C) 2025 David M. Syzdek <david@syzdek.net>.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are
 *  met:
 *
 *     1. Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *
 *     2. Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *
 *     3. Neither the name of the copyright holder nor the names of its
 *        contributors may be used to endorse or promote products derived from
 *        this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 *  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#define __LIB_LIBNETCALC_LIBNETCALC_C 1
#include "libnetcalc.h"


///////////////
//           //
//  Headers  //
//           //
///////////////
// MARK: - Headers

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <stdio.h>


///////////////////
//               //
//  Definitions  //
//               //
///////////////////
// MARK: - Definitions


//////////////////
//              //
//  Prototypes  //
//              //
//////////////////
// MARK: - Prototypes

static int
netcalc_parse_eui48(
         netcalc_net_t *               n,
         char *                        str );


static int
netcalc_parse_eui64(
         netcalc_net_t *               n,
         char *                        str );


static int
netcalc_parse_inet(
         netcalc_net_t *               n,
         char *                        str );


static int
netcalc_parse_inet6(
         netcalc_net_t *               n,
         char *                        str );


/////////////////
//             //
//  Variables  //
//             //
/////////////////
// MARK: - Variables

const netcalc_addr_t _netcalc_netmasks[] =
{  {  .addr_dat8  = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /0

   {  .addr_dat8  = { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /1
   {  .addr_dat8  = { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /2
   {  .addr_dat8  = { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /3
   {  .addr_dat8  = { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /4
   {  .addr_dat8  = { 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /5
   {  .addr_dat8  = { 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /6
   {  .addr_dat8  = { 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /7
   {  .addr_dat8  = { 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /8

   {  .addr_dat8  = { 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /9
   {  .addr_dat8  = { 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /10
   {  .addr_dat8  = { 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /11
   {  .addr_dat8  = { 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /12
   {  .addr_dat8  = { 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /13
   {  .addr_dat8  = { 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /14
   {  .addr_dat8  = { 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /15
   {  .addr_dat8  = { 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /16

   {  .addr_dat8  = { 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /17
   {  .addr_dat8  = { 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /18
   {  .addr_dat8  = { 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /19
   {  .addr_dat8  = { 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /20
   {  .addr_dat8  = { 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /21
   {  .addr_dat8  = { 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /22
   {  .addr_dat8  = { 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /23
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /24

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /25
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /26
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /27
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /28
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /29
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /30
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /31
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /32

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /33
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /34
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /35
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /36
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /37
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /38
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /39
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /40

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /41
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /42
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /43
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /44
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /45
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /46
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /47
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /48

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /49
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /50
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /51
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /52
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /53
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /54
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /55
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /56

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /57
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /58
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /59
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /60
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /61
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /62
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /63
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /64

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /65
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /66
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /67
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /68
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /69
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /70
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /71
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /72

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /73
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /74
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /75
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /76
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /77
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /78
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /79
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /80

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /81
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /82
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /83
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /84
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /85
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /86
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /87
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /88

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /89
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /90
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /91
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /92
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /93
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /94
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /95
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } },  // cidr: /96

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00 } },  // cidr: /97
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00 } },  // cidr: /98
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00 } },  // cidr: /99
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00 } },  // cidr: /100
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00 } },  // cidr: /101
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00 } },  // cidr: /102
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00 } },  // cidr: /103
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00 } },  // cidr: /104

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00 } },  // cidr: /105
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00 } },  // cidr: /106
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00 } },  // cidr: /107
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00 } },  // cidr: /108
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00 } },  // cidr: /109
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00 } },  // cidr: /110
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00 } },  // cidr: /111
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } },  // cidr: /112

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00 } },  // cidr: /113
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00 } },  // cidr: /114
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00 } },  // cidr: /115
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00 } },  // cidr: /116
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00 } },  // cidr: /117
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00 } },  // cidr: /118
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00 } },  // cidr: /119
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 } },  // cidr: /120

   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80 } },  // cidr: /121
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0 } },  // cidr: /122
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0 } },  // cidr: /123
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0 } },  // cidr: /124
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8 } },  // cidr: /125
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc } },  // cidr: /126
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe } },  // cidr: /127
   {  .addr_dat8  = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },  // cidr: /128
};


// IPv4 localhost: 127.0.0.0/8
const netcalc_net_t _netcalc_lo_in =
{
   .net_flags        = NETCALC_AF_INET,
   .net_port         = 0,
   .net_cidr         = 104,
   .net_addr         = { .addr_dat8 = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x01 } },
   .net_scope_name   = NULL
};


// IPv6 localhost: ::1/128
const netcalc_net_t _netcalc_lo_in6 =
{
   .net_flags        = NETCALC_AF_INET6,
   .net_port         = 0,
   .net_cidr         = 128,
   .net_addr         = { .addr_dat8 = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 } },
   .net_scope_name   = NULL
};


/////////////////
//             //
//  Functions  //
//             //
/////////////////
// MARK: - Functions

netcalc_net_t *
netcalc_alloc(
         void )
{
   netcalc_net_t *   net;
   if ((net = malloc(sizeof(netcalc_net_t))) == NULL)
      return(NULL);
   memset(net, 0, sizeof(netcalc_net_t));
   return(net);
}


void
netcalc_free(
         netcalc_net_t *               net )
{
   if (!(net))
      return;
   if ((net->net_scope_name))
      free(net->net_scope_name);
   memset(net, 0, sizeof(netcalc_net_t));
   free(net);
   return;
}


int
netcalc_get_field(
         netcalc_net_t  *              net,
         int                           option,
         void *                        outvalue )
{
   int      family;
   void *   ptr;

   assert( net      != NULL );
   assert( outvalue != NULL );

   family = (int)(net->net_flags & NETCALC_AF);

   switch(option)
   {
      case NETCALC_FLD_ADDR:
      if ((ptr = malloc(sizeof(netcalc_addr_t))) == NULL)
         return(NETCALC_ENOMEM);
      memcpy(ptr, &net->net_addr, sizeof(netcalc_addr_t));
      *((netcalc_addr_t **)outvalue) = (netcalc_addr_t *)ptr;
      return(NETCALC_SUCCESS);

      case NETCALC_FLD_ADDRLEN:
      *((int *)outvalue) = (int)sizeof(netcalc_addr_t);
      return(NETCALC_SUCCESS);

      case NETCALC_FLD_CIDR:
      if ( (family != NETCALC_AF_INET) && (family != NETCALC_AF_INET6) )
         return(NETCALC_EFIELD);
      *((int *)outvalue) = (int)net->net_cidr;
      return(NETCALC_SUCCESS);

      case NETCALC_FLD_FAMILY:
      *((int *)outvalue) = family;
      return(NETCALC_SUCCESS);

      case NETCALC_FLD_FLAGS:
      *((int *)outvalue) = (int)net->net_flags;
      return(NETCALC_SUCCESS);

      case NETCALC_FLD_PORT:
      if ( (family != NETCALC_AF_INET) && (family != NETCALC_AF_INET6) )
         return(NETCALC_EFIELD);
      *((int *)outvalue) = (int)net->net_port;
      return(NETCALC_SUCCESS);

      default:
      break;
   };

   return(NETCALC_EFIELD);
}


int
netcalc_initialize(
         netcalc_net_t **              netp,
         const char *                  address,
         int                           flags )
{
   size_t               addrlen;
   char *               str;
   int                  rc;
   char                 sbuff[NETCALC_ADDRESS_LENGTH];
   char                 scope_name[NETCALC_SCOPE_NAME_LENGTH];
   netcalc_net_t        nbuff;
   netcalc_net_t *      net;

   assert(address != NULL);

   // check flags
   if ((flags & NETCALC_FLG))
      return(NETCALC_EINVAL);
   flags |= ((flags & NETCALC_AF)) ? 0 : NETCALC_AF;

   // prepare netcalc_net_t buffer
   memset(&nbuff,       0, sizeof(netcalc_net_t));
   memset(&scope_name,  0, sizeof(scope_name));
   nbuff.net_scope_name = scope_name;
   nbuff.net_flags      = ((flags & NETCALC_AF)) ? flags : (flags | NETCALC_AF);

   // prepare string buffer
   addrlen = strlen(address);
   if (NETCALC_ADDRESS_LENGTH <= (addrlen+1))
      return(NETCALC_EBUFFLEN);
   memcpy(sbuff, address, addrlen);
   sbuff[addrlen] = '\0';
   str            = sbuff;

   // initial address checks
   //    EUI48:   xx-xx-xx-xx-xx-xx
   //             xx:xx:xx:xx:xx:xx
   //             xxxx.xxxx.xxxx
   //    EUI48:   xx-xx-xx-xx-xx-xx-xx-xx
   //             xx:xx:xx:xx:xx:xx:xx:xx
   //             xxxx.xxxx.xxxx.xxxx
   //    INET:    ddd.ddd.ddd.ddd
   //             ddd.ddd.ddd.ddd/cc
   //             ddd.ddd.ddd.ddd:ppppp
   //    INET6:   ::
   //             ::1
   //             [xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx%iface]:ppppp
   //             [xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx]:ppppp
   //             [xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd]:ppppp
   //             xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx%iface
   //             xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/ccc%iface
   //             xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd/ccc%iface
   //             xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/ccc
   //             xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd/ccc
   //             xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
   // where
   //    * 'ddd' can be a decimal value betweem 0 and 255.
   //    * 'ppppp' can be a decimal value between 0 and 65535
   //    * IPv6 zero compression is supported, but not displayed.
   //
   if ( (addrlen != 14) && (addrlen != 17) )
      nbuff.net_flags &= ~NETCALC_AF_EUI48;
   if ( (addrlen != 23) && (addrlen != 19) )
      nbuff.net_flags &= ~NETCALC_AF_EUI64;
   if ( (addrlen < 7) || (addrlen > 21) )
      nbuff.net_flags &= ~NETCALC_AF_INET;
   if (addrlen < 2)
      nbuff.net_flags &= ~NETCALC_AF_INET6;
   if (!(nbuff.net_flags & NETCALC_AF))
      return(NETCALC_EBADADDR);

   rc = NETCALC_SUCCESS;
   if ((nbuff.net_flags & NETCALC_AF_EUI48))
   {
      nbuff.net_flags   = ((rc = netcalc_parse_eui48(&nbuff, str)) == NETCALC_SUCCESS)
                        ? (nbuff.net_flags & ~NETCALC_AF) | NETCALC_AF_EUI48
                        : (nbuff.net_flags & ~NETCALC_AF_EUI48);
   };
   if ((nbuff.net_flags & NETCALC_AF_EUI64))
   {
      nbuff.net_flags   = ((rc = netcalc_parse_eui64(&nbuff, str)) == NETCALC_SUCCESS)
                        ? (nbuff.net_flags & ~NETCALC_AF) | NETCALC_AF_EUI64
                        : (nbuff.net_flags & ~NETCALC_AF_EUI64);
   };
   if ((nbuff.net_flags & NETCALC_AF_INET))
   {
      nbuff.net_flags   = ((rc = netcalc_parse_inet(&nbuff, str)) == NETCALC_SUCCESS)
                        ? (nbuff.net_flags & ~NETCALC_AF) | NETCALC_AF_INET
                        : (nbuff.net_flags & ~NETCALC_AF_INET);
   };
   if ((nbuff.net_flags & NETCALC_AF_INET6))
   {
      nbuff.net_flags   = ((rc = netcalc_parse_inet6(&nbuff, str)) == NETCALC_SUCCESS)
                        ? (nbuff.net_flags & ~NETCALC_AF) | NETCALC_AF_INET6
                        : (nbuff.net_flags & ~NETCALC_AF_INET6 );
   };
   if (!(nbuff.net_flags & NETCALC_AF))
      return( ((rc)) ? rc : NETCALC_EBADADDR );

   // return if result was not requested
   if (netp == NULL)
      return(0);

   // allocate result
   if ((net = malloc(sizeof(netcalc_net_t))) == NULL)
      return(NETCALC_ENOMEM);
   if ((nbuff.net_scope_name[0]))
   {
      if ((net->net_scope_name = strdup(nbuff.net_scope_name)) == NULL)
      {
         netcalc_free(*netp);
         return(NETCALC_ENOMEM);
      };
   };
   memset(net,             0,                sizeof(netcalc_net_t));
   memcpy(&net->net_addr,  &nbuff.net_addr,  sizeof(netcalc_addr_t));
   net->net_flags   = nbuff.net_flags;
   net->net_port    = nbuff.net_port;
   net->net_cidr    = nbuff.net_cidr;

   return(0);
}


int
netcalc_parse_eui48(
         netcalc_net_t *               n,
         char *                        str )
{
   size_t         pos;
   size_t         digit;
   size_t         byte;
   unsigned       hex;
   uint8_t *      addr8;
   char           delim;

   assert(n    != NULL);
   assert(str  != NULL);

   delim = 0;
   addr8 = n->net_addr.netcalc_addr.netcalc_addr8;

   for(pos = 0, digit = 0, byte = 0, hex = 0; ((str[pos])); pos++)
   {
      switch(str[pos])
      {
         case '0': hex = (hex << 4) +  0; digit++; break;
         case '1': hex = (hex << 4) +  1; digit++; break;
         case '2': hex = (hex << 4) +  2; digit++; break;
         case '3': hex = (hex << 4) +  3; digit++; break;
         case '4': hex = (hex << 4) +  4; digit++; break;
         case '5': hex = (hex << 4) +  5; digit++; break;
         case '6': hex = (hex << 4) +  6; digit++; break;
         case '7': hex = (hex << 4) +  7; digit++; break;
         case '8': hex = (hex << 4) +  8; digit++; break;
         case '9': hex = (hex << 4) +  9; digit++; break;

         case 'a': hex = (hex << 4) + 10; digit++; break;
         case 'b': hex = (hex << 4) + 11; digit++; break;
         case 'c': hex = (hex << 4) + 12; digit++; break;
         case 'd': hex = (hex << 4) + 13; digit++; break;
         case 'e': hex = (hex << 4) + 14; digit++; break;
         case 'f': hex = (hex << 4) + 15; digit++; break;

         case 'A': hex = (hex << 4) + 10; digit++; break;
         case 'B': hex = (hex << 4) + 11; digit++; break;
         case 'C': hex = (hex << 4) + 12; digit++; break;
         case 'D': hex = (hex << 4) + 13; digit++; break;
         case 'E': hex = (hex << 4) + 14; digit++; break;
         case 'F': hex = (hex << 4) + 15; digit++; break;

         case '.':
         if (delim == 0)
            delim = '.';
         if ( (digit != 4) || (delim != '.') )
            return(NETCALC_EBADADDR);
         addr8[10+byte]  = hex;
         hex            = 0;
         digit          = 0;
         byte++;
         break;

         case '-':
         case ':':
         if (delim == 0)
            delim = str[pos];
         if ( (digit != 2) || (delim != str[pos]) )
            return(NETCALC_EBADADDR);
         addr8[10+byte]  = hex;
         hex            = 0;
         digit          = 0;
         byte++;
         break;

         default:
         return(NETCALC_EBADADDR);
      };

      if ( (digit > 2) && ((delim == ':') || (delim == '-')) )
         return(NETCALC_EBADADDR);
      if (digit > 4)
         return(NETCALC_EBADADDR);
      if (byte > 5)
         return(NETCALC_EBADADDR);
   };

   if ( (digit != 2) && ((delim == ':') || (delim == '-')) )
      return(NETCALC_EBADADDR);
   if ( (digit != 4) && (delim == '.') )
      return(NETCALC_EBADADDR);

   addr8[10+byte]  = hex;

   return(0);
}


int
netcalc_parse_eui64(
         netcalc_net_t *               n,
         char *                        str )
{
   size_t         pos;
   size_t         digit;
   size_t         byte;
   unsigned       hex;
   uint8_t *      addr8;
   char           delim;

   assert(n    != NULL);
   assert(str  != NULL);

   delim = 0;
   addr8 = n->net_addr.netcalc_addr.netcalc_addr8;

   for(pos = 0, digit = 0, byte = 0, hex = 0; ((str[pos])); pos++)
   {
      switch(str[pos])
      {
         case '0': hex = (hex << 4) +  0; digit++; break;
         case '1': hex = (hex << 4) +  1; digit++; break;
         case '2': hex = (hex << 4) +  2; digit++; break;
         case '3': hex = (hex << 4) +  3; digit++; break;
         case '4': hex = (hex << 4) +  4; digit++; break;
         case '5': hex = (hex << 4) +  5; digit++; break;
         case '6': hex = (hex << 4) +  6; digit++; break;
         case '7': hex = (hex << 4) +  7; digit++; break;
         case '8': hex = (hex << 4) +  8; digit++; break;
         case '9': hex = (hex << 4) +  9; digit++; break;

         case 'a': hex = (hex << 4) + 10; digit++; break;
         case 'b': hex = (hex << 4) + 11; digit++; break;
         case 'c': hex = (hex << 4) + 12; digit++; break;
         case 'd': hex = (hex << 4) + 13; digit++; break;
         case 'e': hex = (hex << 4) + 14; digit++; break;
         case 'f': hex = (hex << 4) + 15; digit++; break;

         case 'A': hex = (hex << 4) + 10; digit++; break;
         case 'B': hex = (hex << 4) + 11; digit++; break;
         case 'C': hex = (hex << 4) + 12; digit++; break;
         case 'D': hex = (hex << 4) + 13; digit++; break;
         case 'E': hex = (hex << 4) + 14; digit++; break;
         case 'F': hex = (hex << 4) + 15; digit++; break;

         case '.':
         if (delim == 0)
            delim = '.';
         if ( (digit != 4) || (delim != '.') )
            return(NETCALC_EBADADDR);
         addr8[8+byte]  = hex;
         hex            = 0;
         digit          = 0;
         byte++;
         break;

         case '-':
         case ':':
         if (delim == 0)
            delim = str[pos];
         if ( (digit != 2) || (delim != str[pos]) )
            return(NETCALC_EBADADDR);
         addr8[8+byte]  = hex;
         hex            = 0;
         digit          = 0;
         byte++;
         break;

         default:
         return(NETCALC_EBADADDR);
      };

      if ( (digit > 2) && ((delim == ':') || (delim == '-')) )
         return(NETCALC_EBADADDR);
      if (digit > 4)
         return(NETCALC_EBADADDR);
      if (byte > 7)
         return(NETCALC_EBADADDR);
   };

   if ( (digit != 2) && ((delim == ':') || (delim == '-')) )
      return(NETCALC_EBADADDR);
   if ( (digit != 4) && (delim == '.') )
      return(NETCALC_EBADADDR);

   addr8[10+byte]  = hex;

   return(0);
}


int
netcalc_parse_inet(
         netcalc_net_t *               n,
         char *                        str )
{
   size_t         pos;
   size_t         digit;
   size_t         byte;
   unsigned       cidr;
   unsigned       dec;
   uint8_t *      addr8;
   char *         ptr;

   assert(n    != NULL);
   assert(str  != NULL);

   addr8 = n->net_addr.netcalc_addr.netcalc_addr8;

   // check for CIDR
   if ((ptr = strchr(str, '/')) != NULL)
   {
      ptr[0] = '\0';
      if (ptr[1] == '\0')
         return(NETCALC_EBADADDR);
      cidr = (unsigned)strtoul(&ptr[1], &ptr, 10);
      if ( (ptr[0] != '\0') || (cidr > 32) )
         return(NETCALC_EBADADDR);
      n->net_cidr = (uint8_t)cidr;
   };

   for(pos = 0, digit = 0, byte = 0, dec = 0; ((str[pos])); pos++)
   {
      switch(str[pos])
      {
         case '0': dec = (dec * 10) + 0; digit++; break;
         case '1': dec = (dec * 10) + 1; digit++; break;
         case '2': dec = (dec * 10) + 2; digit++; break;
         case '3': dec = (dec * 10) + 3; digit++; break;
         case '4': dec = (dec * 10) + 4; digit++; break;
         case '5': dec = (dec * 10) + 5; digit++; break;
         case '6': dec = (dec * 10) + 6; digit++; break;
         case '7': dec = (dec * 10) + 7; digit++; break;
         case '8': dec = (dec * 10) + 8; digit++; break;
         case '9': dec = (dec * 10) + 9; digit++; break;

         case '.':
         if (digit == 0)
            return(NETCALC_EBADADDR);
         addr8[15-byte] = dec;
         dec            = 0;
         digit          = 0;
         byte++;
         break;

         case ':':
         if ((n->net_cidr))
            return(NETCALC_EBADADDR);
         if ( (byte != 3) || (digit == 0) )
            return(NETCALC_EBADADDR);
         addr8[12+byte] = dec;
         dec            = (unsigned)strtoul(&str[pos+1], &ptr, 10);
         if ( (ptr[0] != '\0') || (dec > 0xffff) )
            return(NETCALC_EBADADDR);
         n->net_port   = (uint16_t)dec;
         n->net_flags &= ~NETCALC_AF;
         n->net_flags |= NETCALC_AF_INET;
         return(0);

         default:
         return(NETCALC_EBADADDR);
      };

      if ( (digit > 3) || (dec > 255) )
         return(NETCALC_EBADADDR);
   };

   if ( (byte != 3) || (digit == 0) )
      return(NETCALC_EBADADDR);

   addr8[12+byte] = dec;

   return(0);
}


int
netcalc_parse_inet6(
         netcalc_net_t *               n,
         char *                        str )
{
   size_t         pos;
   size_t         fwd;
   size_t         digit;
   size_t         wyde;
   size_t         wyde_fwd;
   unsigned       cidr;
   unsigned       hex;
   unsigned       dec;
   char *         ptr;
   char *         scope_name;
   uint8_t *      addr8;
   int            zero;

   assert(n    != NULL);
   assert(str  != NULL);

   if (!(n->net_flags & NETCALC_AF_INET6))
      return(NETCALC_EBADADDR);

   zero        = 0;
   addr8       = n->net_addr.netcalc_addr.netcalc_addr8;
   scope_name  = n->net_scope_name;

   // check for port number
   if (str[0] == '[')
   {
      n->net_flags &= ~NETCALC_AF;
      n->net_flags |=  NETCALC_AF_INET6;
      str = &str[1];
      if ((ptr = strchr(str, ']')) == NULL)
         return(NETCALC_EBADADDR);
      ptr[0] = '\0';
      if (ptr[1] == ':')
      {
         n->net_port  = (uint16_t)strtol(&ptr[2], &ptr, 10);
         if (ptr[0] != '\0')
            return(NETCALC_EBADADDR);
      };
   };

   // check for named scope
   if ((ptr = strchr(str, '%')) != NULL)
   {
      ptr[0] = '\0';
      n->net_flags &= ~NETCALC_AF;
      n->net_flags |=  NETCALC_AF_INET6;
      for(pos = 1; ((ptr[pos])); pos++)
      {
         if (pos >= NETCALC_SCOPE_NAME_LENGTH)
            return(NETCALC_EBUFFLEN);
         if       ( (ptr[pos] >= '0') && (ptr[pos] <= '9') ) scope_name[pos-1] = ptr[pos];
         else if  ( (ptr[pos] >= 'a') && (ptr[pos] <= 'z') ) scope_name[pos-1] = ptr[pos];
         else if  ( (ptr[pos] >= 'A') && (ptr[pos] <= 'Z') ) scope_name[pos-1] = ptr[pos];
         else
         {
            switch(ptr[pos])
            {
               case '.':
               case '-':
               case '_':
               case ':':
               scope_name[pos-1] = ptr[pos];
               break;

               default:
               return(NETCALC_EBADADDR);
            }
         }
      };
      scope_name[pos-1] = '\0';
   };

   // check for CIDR
   if ((ptr = strchr(str, '/')) != NULL)
   {
      if ((n->net_port))
         return(NETCALC_EBADADDR);
      ptr[0] = '\0';
      if (ptr[1] == '\0')
         return(NETCALC_EBADADDR);
      cidr = (unsigned)strtoul(&ptr[1], &ptr, 10);
      if ( (ptr[0] != '\0') || (cidr > 128) )
         return(NETCALC_EBADADDR);
      n->net_cidr = (uint8_t)cidr;
   };

   for(pos = 0, digit = 0, wyde = 0, dec = 0, hex = 0; ((str[pos])); pos++)
   {
      switch(str[pos])
      {
         case '0': hex = (hex << 4) +  0; digit++; break;
         case '1': hex = (hex << 4) +  1; digit++; break;
         case '2': hex = (hex << 4) +  2; digit++; break;
         case '3': hex = (hex << 4) +  3; digit++; break;
         case '4': hex = (hex << 4) +  4; digit++; break;
         case '5': hex = (hex << 4) +  5; digit++; break;
         case '6': hex = (hex << 4) +  6; digit++; break;
         case '7': hex = (hex << 4) +  7; digit++; break;
         case '8': hex = (hex << 4) +  8; digit++; break;
         case '9': hex = (hex << 4) +  9; digit++; break;

         case 'a': hex = (hex << 4) + 10; digit++; break;
         case 'b': hex = (hex << 4) + 11; digit++; break;
         case 'c': hex = (hex << 4) + 12; digit++; break;
         case 'd': hex = (hex << 4) + 13; digit++; break;
         case 'e': hex = (hex << 4) + 14; digit++; break;
         case 'f': hex = (hex << 4) + 15; digit++; break;

         case 'A': hex = (hex << 4) + 10; digit++; break;
         case 'B': hex = (hex << 4) + 11; digit++; break;
         case 'C': hex = (hex << 4) + 12; digit++; break;
         case 'D': hex = (hex << 4) + 13; digit++; break;
         case 'E': hex = (hex << 4) + 14; digit++; break;
         case 'F': hex = (hex << 4) + 15; digit++; break;

         case ':':
         addr8[(wyde*2)+0] = (hex >> 16) & 0xff;
         addr8[(wyde*2)+1] = (hex >>  0) & 0xff;
         if (str[pos+1] == ':')
         {
            if (str[pos+2] == ':')
               return(NETCALC_EBADADDR);
            if ((zero))
               return(NETCALC_EBADADDR);
            zero++;
            pos += 2;
            for(fwd = pos, wyde_fwd = 1; ((str[fwd])); fwd++)
            {
               if (str[fwd] == ':')
               {
                  wyde_fwd++;
                  digit = 0;
               }
               else if (str[fwd] == '.')
                  dec++;
               else if  (  ( (str[fwd] >= '0') && (str[fwd] <= '9') ) ||
                           ( (str[fwd] >= 'a') && (str[fwd] <= 'f') ) ||
                           ( (str[fwd] >= 'A') && (str[fwd] <= 'F') )
                        )
                  continue;
               else
                  return(NETCALC_EBADADDR);
            };
            if ( (dec != 0) && (dec != 3) )
               return(NETCALC_EBADADDR);
            if ((wyde_fwd + wyde) > 7)
               return(NETCALC_EBADADDR);
            wyde     += 7 - (wyde_fwd + wyde);
            if (dec == 3)
               wyde--;
         };
         hex   = 0;
         digit = 0;
         wyde++;
         break;

         default:
         return(NETCALC_EBADADDR);
      };

      // check for IPv4 mapped address
      if (wyde == 6)
      {
         if (!(netcalc_parse_inet(n, &str[pos])))
         {
            n->net_flags |= NETCALC_FLG_V4MAPPED;
            return(0);
         };
      };

      if ( (wyde > 7) || (digit > 4) || (hex > 0xffff) )
         return(NETCALC_EBADADDR);
   };

   if (wyde != 7)
      return(NETCALC_EBADADDR);

   addr8[(wyde*2)+0] = (hex >> 16) & 0xff;
   addr8[(wyde*2)+1] = (hex >>  0) & 0xff;

   return(0);
}


const char *
netcalc_strerror(
         int                           errnum )
{
   switch(errnum)
   {
      case NETCALC_SUCCESS:      return("success");

      case NETCALC_EBADADDR:     return("bad address string");
      case NETCALC_EBUFFLEN:     return("buffer length exceeeded");
      case NETCALC_EFIELD:       return("unknown or unsupported field");
      case NETCALC_EINVAL:       return("invalid argument");
      case NETCALC_ENOMEM:       return("out of virtual memory");

      case NETCALC_EUNKNOWN:     break;
      default:                   break;
   };
   return("unknown error");
}


/* end of source */
